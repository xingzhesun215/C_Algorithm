1.2 常用算法介绍

1.2.1 分治法
将一个难以直接解决的大问题按照相同的概念分割成2个或者更多的子问题,以便各个击破
eg:1个人盖一个房子需要1年,2个人只需要半年,4个人只要3个月,8个人只需要45天

1.2.2 递归法
一个函数或者子函数是由自身所定义或调用的,这就是递归
eg:阶乘 斐波那契

1.2.3 贪心法
从某一起点开始,在每一个解决问题的步骤中使用贪心原则,即采取在当前状态下最有利或最优化的选择,不断地改进改解答,持续在每一个步骤选择最佳的方法,并且逐步逼近给定的目标,当达到某一步骤不能再继续进行时算法停止,以尽可能快地求得更好的解.
贪心算法不能保证最后解为最优解,过早的决定只能在某些约束条件下可行解的范围,但在某些特定情况可以求得最优解
eg:求图的最小生成树 最短路径 霍哈夫曼编码

1.2.4 动态规划法
如果一个问题答案与子问题的答案相关,就能将大问题拆解成各个小问题,其中与分治法最大不同的地方是可以让每一个子问题的答案存储起来,以供下一次求解时直接取用.

eg:斐波那契(可以减少计算量,但需要额外的空间)

1.2.5 迭代法
无法使用公式一次求解,而需要使用迭代
使用循环,每次循环后判断条件

eg:计算1!~n!

1.2.6 枚举法
穷举所有的可能,把问题分为不重复不遗漏的有限种情况


1.2.7 回溯法
也是枚举法的一种,一旦发现不正确的数值,就不再递归到下一层,而是回溯到上一层,以节约时间,是一种走不通就退回再走的方式

eg:老鼠走迷宫
